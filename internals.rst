Zig Compiler Internals
======================
   
.. contents::
.. sectnum::

Introduction
------------

The Zig compiler is implemented mostly in C++ with some parts in Zig userland.

Long-term goals (in no particular order) are as follows:

- become self hosting
- add a fast-debug backend (machine code generator)
- add fine-grained incremental builds
- continue to improve safe-mode code generation

Abstract
--------

This article aims to document various aspects of the implementation of 
the Zig Programming Language in order to help those who are interested in how
things work under the hood and to give a starting point in debugging or contributing
to the project.

Compiler Pipeline
-----------------

.. image:: pipeline.svg

The Zig compiler architecture pipeline is as follows:

- consume Zig source code
- generate tokens (Tokens)
- generate abstract syntax gree (AST)
- generate Src internal representation (SIR)
- generate Gen internal representation (GIR)
- generate LLVM internal representation (LLVM-IR)
- emit machine code

Generate Tokens
~~~~~~~~~~~~~~~

Source code is consumed and tokens are generated by `tokenizer.cpp
<https://github.com/ziglang/zig/blob/master/src/tokenizer.cpp>`_ .

Generate AST
~~~~~~~~~~~~

Tokens are consumed and the AST is generated by `parser.cpp
<https://github.com/ziglang/zig/blob/master/src/parser.cpp>`_ .

Generate SIR
~~~~~~~~~~~~

AST is consumed and SIR is generated by `analyze.cpp
<https://github.com/ziglang/zig/blob/master/src/analyze.cpp>`_
and `ir.cpp
<https://github.com/ziglang/zig/blob/master/src/ir.cpp>`_ .

- execute comptime
- resolve comptime types
- apply result location semantics

Zig has two parts to its internal representation, SIR and GIR where
the "S" in *Src-IR* indicates that it's coming from the source-side of the pipeline and
the "G" in *Gen-IR* indicates that it's heading towards the machine code generation side.

Both SIR and GIR are colloqually known as IR.

Generate GIR
~~~~~~~~~~~~

SIR is consumed and GIR is generated by `ir.cpp
<https://github.com/ziglang/zig/blob/master/src/ir.cpp>`_ .

Generate LLVM-IR
~~~~~~~~~~~~~~~~

GIR is consumed and LLVM-IR is generated by `codegen.cpp
<https://github.com/ziglang/zig/blob/master/src/codegen.cpp>`_ .

Reading IR
----------

This section will briefly describe textual representation of IR for example source ``reduction.zig``:

.. _mike:

.. code:: zig

   export fn reduction() u64 {
       var i: u64 = 999;
       i += 333;
       return i;
   }

   // override panic handler to reduce IR noise
   pub fn panic(msg: []const u8, error_return_trace: ?*@import("builtin").StackTrace) noreturn {
       while (true) {}
   }

SIR
~~~

SIR listing for ``reduction.zig``:

.. code::

   fn reduction() { // (IR)
   Entry_0:
       #1  | ResetResult           | (unknown)   | - | ResetResult(none)
       #2  | ResetResult           | (unknown)   | - | ResetResult(none)
       #3  | ResetResult           | (unknown)   | - | ResetResult(none)
       #4  | Const                 | type        | 2 | u64
       #5  | EndExpr               | (unknown)   | - | EndExpr(result=none,value=u64)
       #6  | Const                 | bool        | 2 | false
       #7  | AllocaSrc             | (unknown)   | 1 | Alloca(align=(null),name=i)
       #8  | ResetResult           | (unknown)   | - | ResetResult(var(#7))
       #9  | ResetResult           | (unknown)   | - | ResetResult(none)
       #10 | Const                 | comptime_int| 2 | 999
       #11 | EndExpr               | (unknown)   | - | EndExpr(result=none,value=999)
       #12 | ImplicitCast          | (unknown)   | 1 | @implicitCast(u64,999)
       #13 | EndExpr               | (unknown)   | - | EndExpr(result=var(#7),value=#12)
       #14 | DeclVarSrc            | void        | - | var i = #7 // comptime = false
       #15 | ResetResult           | (unknown)   | - | ResetResult(none)
       #16 | ResetResult           | (unknown)   | - | ResetResult(none)
       #17 | VarPtr                | (unknown)   | 2 | &i
       #18 | LoadPtr               | (unknown)   | 1 | #17.*
       #19 | ResetResult           | (unknown)   | - | ResetResult(none)
       #20 | Const                 | comptime_int| 2 | 333
       #21 | EndExpr               | (unknown)   | - | EndExpr(result=none,value=333)
       #22 | BinOp                 | (unknown)   | 1 | #18 + 333
       #23 | StorePtr              | void        | - | *#17 = #22
       #24 | Const                 | void        | 2 | {}
       #25 | EndExpr               | (unknown)   | - | EndExpr(result=none,value={})
       #26 | CheckStatementIsVoid  | (unknown)   | - | @checkStatementIsVoid({})
       #27 | ResetResult           | (unknown)   | - | ResetResult(none)
       #28 | ResetResult           | (unknown)   | - | ResetResult(return)
       #29 | VarPtr                | (unknown)   | 1 | &i
       #30 | LoadPtr               | (unknown)   | 4 | #29.*
       #31 | EndExpr               | (unknown)   | - | EndExpr(result=return,value=#30)
       #32 | AddImplicitReturnType | (unknown)   | - | @addImplicitReturnType(#30)
       #35 | TestErrSrc            | (unknown)   | 2 | @testError(#30)
       #36 | TestComptime          | (unknown)   | 3 | @testComptime(#35)
       #37 | CondBr                | noreturn    | - | if (#35) $ErrRetErr_33 else $ErrRetOk_34 // comptime = #36
   ErrRetErr_33:
       #39 | SaveErrRetAddr        | (unknown)   | - | @saveErrRetAddr()
       #40 | Br                    | noreturn    | - | goto $RetStmt_38 // comptime = #36
   ErrRetOk_34:
       #41 | Br                    | noreturn    | - | goto $RetStmt_38 // comptime = #36
   RetStmt_38:
       #42 | Return                | noreturn    | - | return #30
   }

Each line represents an SIR instruction in tabular format columns with columns as follows:

#. debug-id which is unique to the function body
#. trimmed C++ ``struct`` name representing an instruction type
#. Zig type for the instruction as an expression
#. reference count for the instruction
#. syntax (string representation) of the instruction

Intermixed between instructions are basic-block labels in style ``<name>_<debug-id>:``

GIR
~~~

GIR listing for ``reduction.zig``:

.. code::

   fn reduction() { // (analyzed)
   Entry_0:
       #16 | StorePtr              | void        | - | *#12 = 999
       :12 | AllocaGen             | *u64        | 2 | Alloca(align=0,name=i)
       #17 | DeclVarGen            | void        | - | var i: u64 align(8) = #12 // comptime = false
       #20 | VarPtr                | *u64        | 2 | &i
       #21 | LoadPtrGen            | u64         | 1 | loadptr(#20)result=(null)
       #26 | BinOp                 | u64         | 1 | #21 + 333
       #27 | StorePtr              | void        | - | *#20 = #26
       #33 | VarPtr                | *u64        | 1 | &i
       #34 | LoadPtrGen            | u64         | 1 | loadptr(#33)result=(null)
       #39 | Return                | noreturn    | - | return #34
   }

GIR is very similar to SIR and reduced in number of instructions as many have already been consumed by the pipeline. Bear in mind a few things:

- the debug-ids from GIR have no correlation to those from SIR
- many SIR instructions are illegal in GIR
- all types are resolved

We should pause for a moment and examine why one of the instructions in column 1 looks different. Looking backwards from ``:12`` we see that ``#16`` is using ``#12`` and it's an ``AllocaGen``. These are special - the ``:12`` rather than ``#12`` indicates that the previous instruction references it, but it is not code-generated right there in that position. Rather, all the ``AllocaGen`` instructions are code-generated at the very beginning of a function before anything else.

Common IR Instruction Set
-------------------------

note:
   We're going to overload the use of ``diff`` highlighting to draw attention to to certain IR listings.
   Please ignore the unfortunate side-effect exclamation-mark at the beginning of attention lines.

Other
~~~~~

Const
`````

syntax:

   .. code:: bnf

      <Const> ::= <value>

   ``value``
      comptime value

``IrInstructionConst`` is a compile-time instruction.

source-reduction → SIR:

   .. code:: zig

      export fn reduction() void {
         _ = true;
      }

   .. code:: diff

      fn reduction() { // (IR)
      Entry_0:
          #1  | ResetResult           | (unknown)   | - | ResetResult(none)
          #2  | ResetResult           | (unknown)   | - | ResetResult(none)
          #3  | ResetResult           | (unknown)   | - | ResetResult(none)
          #4  | Const                 | *void       | 1 | *_
          #5  | ResetResult           | (unknown)   | - | ResetResult(inst(*_))
     !    #6  | Const                 | bool        | 1 | true
          #7  | EndExpr               | (unknown)   | - | EndExpr(result=inst(*_),value=true)
          #8  | Const                 | void        | 2 | {}
          #9  | EndExpr               | (unknown)   | - | EndExpr(result=none,value={})
          #10 | CheckStatementIsVoid  | (unknown)   | - | @checkStatementIsVoid({})
          #11 | Const                 | void        | 0 | {}
          #12 | Const                 | void        | 3 | {}
          #13 | EndExpr               | (unknown)   | - | EndExpr(result=none,value={})
          #14 | AddImplicitReturnType | (unknown)   | - | @addImplicitReturnType({})
          #15 | Return                | noreturn    | - | return {}
      }

Terminators
~~~~~~~~~~~

Br
``

syntax:

   .. code:: bnf

      <Br> ::= "goto" "$"<dest_block>

   ``dest_block``
      branch to take

``IrInstructionBr`` unconditionally transfers control flow to another basic-block.

source-reduction → GIR:

   .. code:: zig

      export fn reduction(cond: bool) void {
          var a: u64 = 999;
          if (cond) {
              a += 333;
          }
      }

   .. code:: diff

      fn reduction() { // (analyzed)
      Entry_0:
          #16 | StorePtr              | void        | - | *#12 = 999
          :12 | AllocaGen             | *u64        | 2 | Alloca(align=0,name=a)
          #17 | DeclVarGen            | void        | - | var a: u64 align(8) = #12 // comptime = false
          #20 | VarPtr                | *const bool | 1 | &cond
          #21 | LoadPtrGen            | bool        | 1 | loadptr(#20)result=(null)
          #27 | CondBr                | noreturn    | - | if (#21) $Then_25 else $Else_26
      Then_25:
          #30 | VarPtr                | *u64        | 2 | &a
          #31 | LoadPtrGen            | u64         | 1 | loadptr(#30)result=(null)
          #36 | BinOp                 | u64         | 1 | #31 + 333
          #37 | StorePtr              | void        | - | *#30 = #36
     !    #47 | Br                    | noreturn    | - | goto $EndIf_43
      Else_26:
     !    #50 | Br                    | noreturn    | - | goto $EndIf_43
     !EndIf_43:
          #57 | Return                | noreturn    | - | return {}
      }

CondBr
``````

syntax:

   .. code:: bnf

      <CondBr> ::= "if" "(" <condition> ")" "$"<then_block> "else" "$"<else_block>

   ``condition``
      is evaluated as a ``bool``
   ``then_block``
      branch taken if ``condition`` == ``true``
   ``else_block``
      branch taken if ``condition`` == ``false``

``IrInstructionCondBr`` conditionally transfers control flow to other basic-blocks.

source-reduction → GIR:

   .. code:: zig

      export fn reduction(cond: bool) void {
          var a: u64 = 999;
          if (cond) {
              a += 333;
          } else {
              a -= 333;
          }
      }

   .. code:: diff

      fn reduction() { // (analyzed)
      Entry_0:
          #16 | StorePtr              | void        | - | *#12 = 999
          :12 | AllocaGen             | *u64        | 2 | Alloca(align=0,name=a)
          #17 | DeclVarGen            | void        | - | var a: u64 align(8) = #12 // comptime = false
          #20 | VarPtr                | *const bool | 1 | &cond
          #21 | LoadPtrGen            | bool        | 1 | loadptr(#20)result=(null)
     !    #27 | CondBr                | noreturn    | - | if (#21) $Then_25 else $Else_26
     !Then_25:
          #30 | VarPtr                | *u64        | 2 | &a
          #31 | LoadPtrGen            | u64         | 1 | loadptr(#30)result=(null)
          #36 | BinOp                 | u64         | 1 | #31 + 333
          #37 | StorePtr              | void        | - | *#30 = #36
          #60 | Br                    | noreturn    | - | goto $EndIf_56
     !Else_26:
          #44 | VarPtr                | *u64        | 2 | &a
          #45 | LoadPtrGen            | u64         | 1 | loadptr(#44)result=(null)
          #50 | BinOp                 | u64         | 1 | #45 - 333
          #51 | StorePtr              | void        | - | *#44 = #50
          #63 | Br                    | noreturn    | - | goto $EndIf_56
      EndIf_56:
          #70 | Return                | noreturn    | - | return {}
      }

Return
``````

syntax:

   .. code:: bnf

      <Return> ::= "return" "{}"

``IrInstructionReturn`` unconditionally transfers control flow back to the caller basic-block.

source-reduction → GIR:

   .. code:: zig

      export fn reduction() void {}

   .. code:: diff

      fn reduction() { // (analyzed)
      Entry_0:
     !    #5  | Return                | noreturn    | - | return {}
      }

Compiler Building
------------------

Overview
~~~~~~~~

- cmake
- compile common C++ sources
- compile ``userland.o`` C++ sources
- link ``zig0`` stage0 compiler
- compile ``libuserland.a`` Zig sources
- link ``zig`` stage1 compiler

``userland.o``
   This is a shim implementation of ``libuserland.a`` and is completely implemented in C++.
   All exported symbols must match ``libuserland.a``. ``zig0`` links against but never makes
   calls against the shim. All shims are implemented as panics.

``zig0``
   Also known as the *stage0* compiler.
   It links against ``userland.o`` and is a functionally limited compiler but is robust
   enough to build ``libuserland.a``.

   ``zig0`` can build Zig source code, run tests and produce executables.
   It can be debugged with a native debugger such as ``gdb`` or ``lldb``.
   But it cannot do things like ``zig0 build ...`` because part of that functionality
   is implemented in ``libuserland.a``.

   During Zig compiler development it may be of use to develop against ``zig0`` in an interative fashion.

   Here is an example of using stage0 to emit IR and LLVM-IR:

   .. code:: sh

      $ _build/zig0 --override-std-dir std --override-lib-dir . build-obj reduction.zig --verbose-ir --verbose-llvm-ir

   and a corresponding example of launching ``lldb`` debugger:

   .. code:: sh

      $ lldb _build/zig0 -- --override-std-dir std --override-lib-dir . build-obj reduction.zig

``libuserland.a``
   This is a support library implemented in Zig userland.
   It replaces all shims from ``userland.o`` with implementations.
   ``zig`` links against this library **instead** of ``userland.o``.

``zig``
   Also known as the *stage1* compiler.
   It links against ``libuserland.a`` and is a fully functional compiler.
   It can be debugged with a native debugger such as ``gdb`` or ``lldb``.

How-To: Common Tasks
--------------------

Iteratively build compiler
~~~~~~~~~~~~~~~~~~~~~~~~~~

note: for stage1 replace ``zig0`` with ``zig``:

using ``make``:

   .. code:: bash

      $ make -C _build zig0
      $ _build/zig0 --override-std-dir std --override-lib-dir . version

using ``ninja``:

   .. code:: bash

      $ ninja -C _build zig0
      $ _build/zig0 --override-std-dir std --override-lib-dir . version

Debug compiler
~~~~~~~~~~~~~~

note: for stage1 replace ``zig0`` with ``zig``:

using ``gdb``:

   .. code:: bash

      $ _build/zig0 --override-std-dir std --override-lib-dir build-obj foobar.zig
      segmentation fault
      $ gdb --args _build/zig0 --override-std-dir std --override-lib-dir build-obj foobar.zig

using ``lldb``:

   .. code:: bash

      $ _build/zig0 --override-std-dir std --override-lib-dir build-obj foobar.zig
      segmentation fault
      $ lldb _build/zig0 -- --override-std-dir std --override-lib-dir build-obj foobar.zig

Print IR listing
~~~~~~~~~~~~~~~~

note: for stage1 replace ``zig0`` with ``zig``:

   .. code:: bash

      $ _build/zig0 --override-std-dir std --override-lib-dir build-obj reduction.zig --verbose-ir

Configure for ``ninja``
~~~~~~~~~~~~~~~~~~~~~~~

   .. code:: bash

      $ cd ~/zig/work
      $ mkdir _build
      $ cmake -G Ninja -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/opt/zig -DCMAKE_PREFIX_PATH=/opt/llvm-8.0.1

Best Practices
--------------

Always direct stage0 to workspace
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

It is recommended to override ``std`` and ``lib`` dirs for ``zig0``.

``zig build`` functionality is responsible for completing a compiler install.
Since it is likely ``zig0`` development involves writing tests and userland changes those files cannot be installed until your development is able to progress to stage1.

Reduce and Reduce and Reduce Again
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~



.. |path.zig.workspace|    replace:: ~/zig/work
.. |path.zig.build|        replace:: _build
.. |path.zig.build.zig|    replace:: _build/zig
.. |path.zig.build.zig0|   replace:: _build/zig0
.. |flags.zig.override|    replace:: --override-std-dir std --override-lib-dir .
