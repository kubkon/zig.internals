Zig Compiler Internals
======================
   
.. contents::
.. sectnum::

Introduction
------------

The Zig compiler is implemented mostly in C++ with some parts in Zig userland.

Long-term goals (in no particular order) are as follows:

- become self hosting
- add a fast-debug backend (machine code generator)
- add fine-grained incremental builds
- continue to improve safe-mode code generation

Abstract
--------

This article aims to document various aspects of the implementation of 
the Zig Programming Language in order to help those who are interested in how
things work and to give a starting point for anyone interested in debugging
or contributing to the project.

Compiler Building
------------------

Overview
~~~~~~~~

- cmake
- compile common C++ sources
- compile ``userland.o`` C++ sources
- link ``zig0`` stage0 compiler
- compile ``libuserland.a`` Zig sources
- link ``zig`` stage1 compiler

``userland.o``
   This is a shim implementation of ``libuserland.a`` and is completely implemented in C++.
   All exported symbols must match ``libuserland.a``. ``zig0`` links against but never makes
   calls against the shim. All shims are implemented as panics.

``zig0``
   Also known as the *stage0* compiler.
   It links against ``userland.o`` and is a functionally limited compiler but is robust
   enough to build ``libuserland.a``.

   ``zig0`` can build Zig source code, run tests and produce executables.
   It can be debugged with a native debugger such as ``gdb`` or ``lldb``.
   But it cannot do things like ``zig0 build ...`` because part of that functionality
   is implemented in ``libuserland.a``.

   During Zig compiler development it may be of use to develop against ``zig0`` in an interative fashion.

   Here is an example of using stage0 to emit IR and LLVM-IR:

   .. code:: sh

      $ _build/zig0 --override-std-dir std --override-lib-dir . build-obj reduction.zig --verbose-ir --verbose-llvm-ir

   and a corresponding example of launching ``lldb`` debugger:

   .. code:: sh

      $ lldb _build/zig0 -- --override-std-dir std --override-lib-dir . build-obj reduction.zig

``libuserland.a``
   This is a support library implemented in Zig userland.
   It replaces all shims from ``userland.o`` with implementations.
   ``zig`` links against this library **instead** of ``userland.o``.

``zig``
   Also known as the *stage1* compiler.
   It links against ``libuserland.a`` and is a fully functional compiler.
   It can be debugged with a native debugger such as ``gdb`` or ``lldb``.

Here is a short comparison: building and executing ``zig0`` vs ``zig``.
Note the final lines where we short-cut the build process to only build ``zig0`` to save time.
Both show command-line usage to force running from a source repository instead of an install dir.
However, in the case of ``zig0`` it is almost always necessary because nothing will get installed
until ``libuserland.a`` is produced.

``configure, build and execute zig0``

    .. code:: sh

        $ cd ~/zig/work
        $ mkdir _build
        $ cmake -G Ninja -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/opt/zig -DCMAKE_PREFIX_PATH=/opt/llvm-8.0.1
        $ ninja -C _build zig0
        $ _build/zig0 --override-std-dir std --override-lib-dir . version

``configure, build and execute zig``

    .. code:: sh

        $ cd ~/zig/work
        $ mkdir _build
        $ cmake -G Ninja -S . -B _build -DCMAKE_BUILD_TYPE=Debug -DCMAKE_INSTALL_PREFIX=/opt/zig -DCMAKE_PREFIX_PATH=/opt/llvm-8.0.1
        $ ninja -C _build zig
        $ _build/zig --override-std-dir std --override-lib-dir . version

Compiler Pipeline
-----------------

.. image:: internals.svg

The Zig compiler architecture pipeline is as follows:

- consume Zig source code
- generate tokens (Tokens)
- generate abstract syntax gree (AST)
- generate Src internal representation (SIR)
- generate Gen internal representation (GIR)
- generate LLVM internal representation (LLVM-IR)
- emit machine code

Generate Tokens
~~~~~~~~~~~~~~~

Source code is consumed and tokens are generated by `tokenizer.cpp
<https://github.com/ziglang/zig/blob/master/src/tokenizer.cpp>`_ .

Generate AST
~~~~~~~~~~~~

Tokens are consumed and the AST is generated by `parser.cpp
<https://github.com/ziglang/zig/blob/master/src/parser.cpp>`_ .

Generate SIR
~~~~~~~~~~~~

AST is consumed and SIR is generated by `analyze.cpp
<https://github.com/ziglang/zig/blob/master/src/analyze.cpp>`_
and `ir.cpp
<https://github.com/ziglang/zig/blob/master/src/ir.cpp>`_ .

- execute comptime
- resolve comptime types
- apply result location semantics

Zig has two parts to its internal representation, SIR and GIR where
the "S" in *Src-IR* indicates that it's coming from the source-side of the pipeline and
the "G" in *Gen-IR* indicates that it's heading towards the machine code generation side.

Both SIR and GIR are colloqually known as IR.

Generate GIR
~~~~~~~~~~~~

SIR is consumed and GIR is generated by `ir.cpp
<https://github.com/ziglang/zig/blob/master/src/ir.cpp>`_ .

Generate LLVM-IR
~~~~~~~~~~~~~~~~

GIR is consumed and LLVM-IR is generated by `codegen.cpp
<https://github.com/ziglang/zig/blob/master/src/codegen.cpp>`_ .

Reading Verbose IR
------------------

This section will briefly describe textual representation of IR for example source ``reduction.zig``:

.. code:: zig

   export fn reduction() u64 {
       var i: u64 = 999;
       i += 333;
       return i;
   }

   // override panic handler to reduce IR noise
   pub fn panic(msg: []const u8, error_return_trace: ?*@import("builtin").StackTrace) noreturn {
       while (true) {}
   }

SIR
~~~

SIR is more difficult to find because it doesn't include a global function name when printed.
One workaround is to first find the GIR which contains the function name and then backup to a larger group
of instructions without a function name.

SIR listing for ``reduction.zig``:

.. code::

   { // (IR)
   Entry_0:
       #1  | ResetResult           | (unknown)   | - | ResetResult(none)
       #2  | ResetResult           | (unknown)   | - | ResetResult(none)
       #3  | ResetResult           | (unknown)   | - | ResetResult(none)
       #4  | Const                 | type        | 2 | u64
       #5  | EndExpr               | (unknown)   | - | EndExpr(result=none,value=u64)
       #6  | Const                 | bool        | 2 | false
       #7  | AllocaSrc             | (unknown)   | 1 | Alloca(align=(null),name=i)
       #8  | ResetResult           | (unknown)   | - | ResetResult(var(#7))
       #9  | ResetResult           | (unknown)   | - | ResetResult(none)
       #10 | Const                 | comptime_int| 2 | 999
       #11 | EndExpr               | (unknown)   | - | EndExpr(result=none,value=999)
       #12 | ImplicitCast          | (unknown)   | 1 | @implicitCast(u64,999)
       #13 | EndExpr               | (unknown)   | - | EndExpr(result=var(#7),value=#12)
       #14 | DeclVarSrc            | void        | - | var i = #7 // comptime = false
       #15 | ResetResult           | (unknown)   | - | ResetResult(none)
       #16 | ResetResult           | (unknown)   | - | ResetResult(none)
       #17 | VarPtr                | (unknown)   | 2 | &i
       #18 | LoadPtr               | (unknown)   | 1 | #17.*
       #19 | ResetResult           | (unknown)   | - | ResetResult(none)
       #20 | Const                 | comptime_int| 2 | 333
       #21 | EndExpr               | (unknown)   | - | EndExpr(result=none,value=333)
       #22 | BinOp                 | (unknown)   | 1 | #18 + 333
       #23 | StorePtr              | void        | - | *#17 = #22
       #24 | Const                 | void        | 2 | {}
       #25 | EndExpr               | (unknown)   | - | EndExpr(result=none,value={})
       #26 | CheckStatementIsVoid  | (unknown)   | - | @checkStatementIsVoid({})
       #27 | ResetResult           | (unknown)   | - | ResetResult(none)
       #28 | ResetResult           | (unknown)   | - | ResetResult(return)
       #29 | VarPtr                | (unknown)   | 1 | &i
       #30 | LoadPtr               | (unknown)   | 4 | #29.*
       #31 | EndExpr               | (unknown)   | - | EndExpr(result=return,value=#30)
       #32 | AddImplicitReturnType | (unknown)   | - | @addImplicitReturnType(#30)
       #35 | TestErrSrc            | (unknown)   | 2 | @testError(#30)
       #36 | TestComptime          | (unknown)   | 3 | @testComptime(#35)
       #37 | CondBr                | noreturn    | - | if (#35) $ErrRetErr_33 else $ErrRetOk_34 // comptime = #36
   ErrRetErr_33:
       #39 | SaveErrRetAddr        | (unknown)   | - | @saveErrRetAddr()
       #40 | Br                    | noreturn    | - | goto $RetStmt_38 // comptime = #36
   ErrRetOk_34:
       #41 | Br                    | noreturn    | - | goto $RetStmt_38 // comptime = #36
   RetStmt_38:
       #42 | Return                | noreturn    | - | return #30
   }

Each line represents an SIR instruction:

- column 1 is the debug-id which is unique to the function body
- column 2 is the trimmed C++ ``struct`` name representing an instruction type
- column 3 is the Zig type for the instruction as an expression
- column 4 is a reference count for the instruction
- column 5 is a string representation of the instruction state including any operands

Intermixed between instructions are basic-block labels in style ``<name>_<debug-id>:``

GIR
~~~

GIR listing for ``reduction.zig``:

.. code::

   fn reduction() { // (analyzed)
   Entry_0:
       #16 | StorePtr              | void        | - | *#12 = 999
       :12 | AllocaGen             | *u64        | 2 | Alloca(align=0,name=i)
       #17 | DeclVarGen            | void        | - | var i: u64 align(8) = #12 // comptime = false
       #20 | VarPtr                | *u64        | 2 | &i
       #21 | LoadPtrGen            | u64         | 1 | loadptr(#20)result=(null)
       #26 | BinOp                 | u64         | 1 | #21 + 333
       #27 | StorePtr              | void        | - | *#20 = #26
       #33 | VarPtr                | *u64        | 1 | &i
       #34 | LoadPtrGen            | u64         | 1 | loadptr(#33)result=(null)
       #39 | Return                | noreturn    | - | return #34
   }

GIR is very similar to SIR and is reduced in number of instructions as many have already been consumed by the pipeline. Bear in mind a few things:

- the debug-ids from GIR have no correlation to those from SIR
- many SIR instructions are illegal in GIR
- all types are resolved

We should pause for a moment and examine why one of the instructions in column 1 looks different. Looking backwards from ``:12`` we see that ``#16`` is using ``#12`` and it's an ``AllocaGen``. These are special - the ``:12`` rather than ``#12`` indicates that the previous instruction references it, but it is not code-generated right there in that position. Rather, all the ``AllocaGen`` instructions are code-generated at the very beginning of a function before anything else.

Common IR Instruction Set
-------------------------

Other
~~~~~

Const
`````

``IrInstructionConst`` is a value known at compile-time.

Terminators
~~~~~~~~~~~

Br
``

``IrInstructionBr`` unconditionally transfers control flow to a different basic-block.

CondBr
``````

`IrInstructionCondBr` conditionally transfers control flow.

``operands``
   ``condition``
      is evaluated as a ``bool``
   ``then_block``
      branch taken if ``condition`` == ``true``
   ``else_block``
      branch taken if ``condition`` == ``false``

..

   source-reduction → GIR:

   .. code:: zig

   export fn reduction(cond: bool) void {
       var a: u64 = 999;
       if (cond) {
           a += 333;
       } else {
           a -= 333;
       }
   }

   .. code::

      fn reduction() { // (analyzed)
      Entry_0:
          #16 | StorePtr              | void        | - | *#12 = 999
          :12 | AllocaGen             | *u64        | 2 | Alloca(align=0,name=a)
          #17 | DeclVarGen            | void        | - | var a: u64 align(8) = #12 // comptime = false
          #20 | VarPtr                | *const bool | 1 | &cond
          #21 | LoadPtrGen            | bool        | 1 | loadptr(#20)result=(null)
          #27 | CondBr                | noreturn    | - | if (#21) $Then_25 else $Else_26
      Then_25:
          #30 | VarPtr                | *u64        | 2 | &a
          #31 | LoadPtrGen            | u64         | 1 | loadptr(#30)result=(null)
          #36 | BinOp                 | u64         | 1 | #31 + 333
          #37 | StorePtr              | void        | - | *#30 = #36
          #60 | Br                    | noreturn    | - | goto $EndIf_56
      Else_26:
          #44 | VarPtr                | *u64        | 2 | &a
          #45 | LoadPtrGen            | u64         | 1 | loadptr(#44)result=(null)
          #50 | BinOp                 | u64         | 1 | #45 - 333
          #51 | StorePtr              | void        | - | *#44 = #50
          #63 | Br                    | noreturn    | - | goto $EndIf_56
      EndIf_56:
          #70 | Return                | noreturn    | - | return {}
      }

      - ``#27`` is ``CondBr`` instruction
      - ``#21`` is ``condition``
      - ``Then_25`` is ``then_block``
      - ``Else_26`` is ``else_block``

Return
``````

   source-reduction → GIR:

   .. code:: zig

      export fn reduction() void {}

   .. code::

      fn reduction() { // (analyzed)
      Entry_0:
          #5  | Return                | noreturn    | - | return {}
      }
